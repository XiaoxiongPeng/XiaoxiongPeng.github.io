<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM之垃圾回收]]></title>
    <url>%2F2018%2F07%2F30%2FJVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[内存垃圾回收是JVM运行过程中非常重要的一个环节，对JVM的性能起着关键性的作用。垃圾收集器有许多种，它们各有特色，在一个场景中选择一个合适的垃圾收集器能让JVM的性能更上层楼。 可达性分析算法 当一个对象从GC roots不可达时，就认为这个对象是没有用的可以被回收。GC roots包括以下几种： 虚拟机栈中(栈帧中的本地变量表)引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 GC Roots可达的对象就不会被回收了吗？不，这还要看是什么样的引用类型。Java中有四种引用类型： 强引用类型(strong reference)代码中存在如Object o=new Object(),o就是强引用，只要引用还在，这个对象就不会被回收。 软引用类型(soft reference)软引用常用在缓存中，当内存不够用时，GC会回收软引用引用的对象。当系统即将要发生内存溢出之前异常之前，将会把这些对象列入回收范围中进行二次回收，若这次回收后还是没有足够的内存，才会抛出内存溢出异常。 弱引用类型(weak reference)弱引用是比软引用更弱的引用，被弱引用引用的对象只能存活到下一次GC之前，每次GC都会回收弱引用的对象，不管内存是否足够。 虚引用类型(phantom reference)虚引用是最弱的引用，任何时候从虚引用获取对象都是null，给对象设置虚引用的目的只有一个，那就是对象被回收时收到系统通知。 安全点（区域）和Stop The World 只有当所有线程都到了安全点(区域)，“Stop the world”后才能进行GC。 回收过程 对象被回收会经过两次标记。第一次标记是是筛选出对象是否要执行finalize()方法，如果对象没有override它的finalize()方法或者它的finalize()方法已经被系统执行过，这两种情况都会被视为“没必要执行”，反之，就和把对象放入一个名为F-Queue的队列中，并在稍后由一个虚拟机创建的低优先级的Finalizer线程执行，但是不承诺等待finalize()执行完。 finalize()是对象在GC过程中拯救自己的唯一机会，并且只能有一次(因为一个对象的一生中finalize()只会被系统调用一次)。在finalize()中把自己与存活的对象建立起关联(如把this关键字赋给某个对象的成员变量)，那么在第二次标记中这个对象将会被移出“即将回收”集合。 两次标记完成后，这一次的回收工作就完成了。 什么时候触发GC不同的“年龄代”的对象回收的频率不一样。堆一般划分为Eden，Survivor和Tenured/Old空间： 老年代空间比新生代空间大，新生代空间分为Eden和两个Survivor空间，比例为8：1：1。 新生代GC(Minor GC)：指在新生代发生的垃圾回收动作，因为Java对象大多具有朝生夕死的特点，所以Minor GC 非常频繁，一般回收速度也很快。Minor GC采用复制收集算法进行回收，每次清理Eden和一个Survivor区，将存活的对象复制到另一个Survivor区，下一次Minor GC清理Eden和另一个Survivor区，总是有一个Survivor区是空的用来保存下次Minor GC的存活对象，如果这个Survivor区空间不够，那么就放入老年代中，老年代都不够那么就进行一个Major GC。在新生代经过数次(默认15，可配置)回收都还存活的对象就可以进入老年代。 老年代GC(Major GC)：指发生在老年代的GC，出现了Major GC，通常伴随着Minor GC(但非绝对，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC速度一般比Minor GC慢10倍以上。 Full GC 通常进行Major GC时就会进行Full GC，Full GC除了回收新生代、老年代和永久代(方法区)外，还会顺便回收(释放)直接内存。Minor GC 触发机制当年轻代满时就会触发Minor GC，这里的年轻代指的是Eden区，Survivor区满不会引发GC。Survivor区满时就把多余的对象放到老年代，大对象直接放到老年代。老年代有空间分配担保机制。Major GC 触发机制当老年代满时会引发Major GCFull GC 触发机制引发Full GC的条件如下（1）调用System.gc时，系统建议执行Full GC，但是不必然执行（2）老年代空间不足（3）方法区空间不足（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小回收方法区方法区又称为永久代，但是永久代不代表不会被回收，只是GC很少在这个区域进行。在这里通常是回收常量和卸载类。回收直接内存发生Full GC时。垃圾收集器垃圾收集器种类繁多，每个都有自己的特色。在不同的场景下选择不同的的垃圾收集器能使JVM的性能最优。 参考：1.https://blog.csdn.net/qq_34707744/article/details/792887872.https://segmentfault.com/a/1190000004926898?_ea=1734786#articleHeader193.https://blog.csdn.net/antony9118/article/details/514255814.https://blog.csdn.net/u010796790/article/details/522137085.https://blog.csdn.net/lqp276/article/details/52249438]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM之内存模型]]></title>
    <url>%2F2018%2F07%2F27%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java虚拟机在运行时会把其所管理的内存区域划分为若干个不同的数据区域，这些区域随着JVM的启动而创建，有的随着用户线程的启动和结束而创建和销毁。 上图是JDK7的虚拟机规范，在JDK8中方法区被metaspace(元数据空间)取代(从方法区(或者元数据区)的用途来看，“元数据区”的命名更贴切)。 程序计数器 程序计数器是一个记录着当前线程所执行的字节码的行号指示器，Java代码编译后的字节码在未经过JIT编译前是通过“字节码解释器”进行解释执行，简单的工作原理为解释器读取装载入内存的字节码，安装顺序执行指令。假设只有一个线程，那么不需要程序计数器也能实现顺序执行指令，但是由于是多线程，那么线程间切换执行时就需要记录当前线程执行的位置，下次切换回来后能继续执行下去，所以每一个线程都拥有一个程序计数器。 但是只有执行Java代码时程序计数器才会有值，如执行native方法时，程序计数器为空(undefined)，因为native方法是Java通过JNI直接调用本地C/C++等代码，本地方法的内存分配不属于JVM的管理范畴。 程序计数器很小，也是jvm内存模型中唯一没有定义OutOfMemoryError的内存区域。 Java虚拟机栈 虚拟机栈是用于描述Java方法执行的内存模型。 每个Java方法执行时，会创建一个栈帧(stack frame)，栈帧的结构分为局部变量表，操作数栈，动态链接和方法出口几个部分。我们常说的”堆内存，栈内存“中的栈内存通常指的就是虚拟机栈。 方法调用时，创建栈帧并压入虚拟机栈，方法结束时，栈帧出栈并销毁。 若单个线程请求的栈深度大于虚拟机允许的深度会抛出StackOverFlowError。JVM为每个线程的虚拟机栈分配一定大小的内存(-Xss参数)，因此虚拟机栈能容纳的栈帧数量是有限的，不断进栈而不出栈(如无限递归)会耗尽虚拟机栈的空间。 不同于StackOverFlowError，当虚拟机栈无法再申请到内存空间时会发生OutOfMemoryError，虚拟机栈的最大空间约等于JVM进程能占用的最大内存空间(依赖于操作系统，如32位Windows进程能占用的内存空间最大为2GB)，当整个JVM进程的内存不够用时，这时虚拟机栈想要再申请内存，那么就会发生OutOfMemoryError了。 虚拟机栈也是线程隔离的，一个线程有一个虚拟机栈。 本地方法栈 本地方法栈的功能和虚拟机栈类似，只不过一个为Java方法服务，一个为本地方法服务。不同的JVM实现对本地方法栈的实现不一样，如HotSpot选择合并了虚拟机栈和本地方法栈。 Java堆 对于大多数应用来说，堆是虚拟机中内存管理中的最大的一块。 堆是所有线程共享的，所有的对象实例和数组都放到这里(但随着JIT的发展和逃逸分析技术的逐渐成熟，所有对象都在堆上也不那么绝对了)。堆是GC管理的主要区域，由于堆是所有线程共享的，在内存分配时需要同步会造成一些性能开销，所以为了性能Java堆中也可能会划分出线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB，默认开启，可通过开关配置)。 方法区 方法区和Java堆一样是线程共享的，用于存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。虽然JVM规范将其描述为堆的一个逻辑分区，但是它却有一个别名叫Non-heap。Hotspot把垃圾回收扩展至方法区并使用永久代实现，但是把方法区称为永久代是不恰当的。方法区可以选择不实现垃圾回收，相对而言，GC在这里比较少出现，在这里垃圾回收的目标主要是常量回收和类的卸载，这部分的回收是有必要的。 运行时常量池 运行时常量池是是方法区的一部分。Class文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。 运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语音并不要求常量一定只能在编译期产生，也可在运行期动态加入，如使用String.intern()方法。 直接内存 直接内存不属于JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域，但是这部分内存被频繁地使用，而且也可能导致OutOfMemoryError出现。 NIO(new Input/Output)类引入了一种基于通道与缓冲区的IO方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用，这样在一些场景中能显著提高性能，因为避免了在Java堆和native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，还是会受到本机总内存的限制。通常管理员在给JVM分配内存时会忽略直接内存的大小，使得各个内存区域的总和大于本机实际内存，当JVM动态扩展内存时就会发生OutOfMemoryError。 从内存角度看待Java对象的创建 类加载检查 JVM遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那么首先执行相应的类的加载过程。 对象分配内存 对象所需内存的大小在类加载完后便完全确定(对象内存布局)。根据Java堆中是否规整，有两种内存分配方式： 指针碰撞内存是规整的，使用过的在一边，未使用的在一边，中间放一个指针作为分界指示器，内存分配时把指针移动一段与分配内存大小相等的距离。 空闲列表内存是不规整的，维持一张表记录那些内存是空闲的以便于内存分配。 并发处理 对象创建时非常频繁的行为，在并发情况下并不安全。所以有同步重试和本地线程分配缓冲(TLAB)来保证这一过程安全。 内存空间初始化 JVM把分配到的内存空间全部初始化为0(不包括对象头)，如果使用了TLAB这个过程会提前到TLAB分配时执行。 对象设置 虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息放在对象头中。 执行init() 在上面的工作都完成后，从虚拟机的角度看，一个新的对象已经产生了。但是从Java程序的角度看，对象还没有init，所有字段都为0。一般来说(由字节码中是否跟随invokespecial指令决定)，执行new指令后会接着执行init()方法，把对象照程序员的意愿进行初始化。 对象内存布局 在HotSpot中，对象在内存中可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。 对象头 HotSpot中的对象头包括两部分信息：运行时数据和类型指针。 运行时数据用于存储对象自身的运行时数据如hashCode、GC分代年龄、锁状态、线程持有的锁，偏向线程ID和偏向时间等。 类型指针即指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。如果对象是一个数组，那么对象头中还必须有一块记录数组长度的数据。 实例数据 实例数据是存储对象真正有效的信息的，记录字段内容(包括从父类中继承的)，相等宽度的字段总是分配到一起，这样可以更紧凑，提高内存使用。 对齐补充 HotSpot要求对象的起始地址必须是8字节的整数倍，也就是对象大小也必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或2倍)，因此，当对象实例部分没有对齐时必须通过对齐来补全。 对象访问定位 Java程序需要通过栈上的引用数据来操作堆上的具体对象。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。 句柄，可以理解为指向指针的指针，维护指向对象的指针变化，而对象的句柄本身不发生变化；指针，指向对象，代表对象的内存地址。 句柄Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。 直接指针如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一篇 博客开篇词]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%AC%AC%E4%B8%80%E7%AF%87%20%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[以后将会每周更新一篇文章。 ——2018年7月19号 晚]]></content>
      <tags>
        <tag>开天辟地</tag>
      </tags>
  </entry>
</search>

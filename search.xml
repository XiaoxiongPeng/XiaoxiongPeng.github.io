<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JVM 内存模型</title>
      <link href="/2018/07/27/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/07/27/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>   Java虚拟机在运行时会把其所管理的内存区域划分为若干个不同的数据区域，这些区域随着JVM的启动而创建，有的随着用户线程的启动和结束而创建和销毁。</p><a id="more"></a><img src="/2018/07/27/JVM内存模型/JVM内存模型.png" title="JVM内存模型"><p>上图是JDK7的虚拟机规范，在JDK8中方法区被metaspace(元数据空间)取代(从方法区(或者元数据区)的用途来看，“元数据区”的命名更贴切)。</p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>   程序计数器是一个记录着当前线程所执行的字节码的行号指示器，Java代码编译后的字节码在未经过JIT编译前是通过“字节码解释器”进行解释执行，简单的工作原理为解释器读取装载入内存的字节码，安装顺序执行指令。假设只有一个线程，那么不需要程序计数器也能实现顺序执行指令，但是由于是多线程，那么线程间切换执行时就需要记录当前线程执行的位置，下次切换回来后能继续执行下去，所以每一个线程都拥有一个程序计数器。<br>   但是只有执行Java代码时程序计数器才会有值，如执行native方法时，程序计数器为空(undefined)，因为native方法是Java通过JNI直接调用本地C/C++等代码，本地方法的内存分配不属于JVM的管理范畴。<br>   程序计数器很小，也是jvm内存模型中唯一没有定义OutOfMemoryError的内存区域。</p><h1 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h1><p>   虚拟机栈是用于描述Java方法执行的内存模型。<br>   每个Java方法执行时，会创建一个栈帧(stack frame)，栈帧的结构分为局部变量表，操作数栈，动态链接和方法出口几个部分。我们常说的”堆内存，栈内存“中的栈内存通常指的就是虚拟机栈。<br>   方法调用时，创建栈帧并压入虚拟机栈，方法结束时，栈帧出栈并销毁。<br>   若单个线程请求的栈深度大于虚拟机允许的深度会抛出StackOverFlowError。JVM为每个线程的虚拟机栈分配一定大小的内存(-Xss参数)，因此虚拟机栈能容纳的栈帧数量是有限的，不断进栈而不出栈(如无限递归)会耗尽虚拟机栈的空间。<br>   不同于StackOverFlowError，当虚拟机栈无法再申请到内存空间时会发生OutOfMemoryError，虚拟机栈的最大空间约等于JVM进程能占用的最大内存空间(依赖于操作系统，如Windows进程能占用的内存空间最大为2GB)，当整个JVM进程的内存不够用时，这时虚拟机栈想要再申请内存，那么就会发生OutOfMemoryError了。<br>   虚拟机栈也是线程隔离的，一个线程有一个虚拟机栈。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>   本地方法栈的功能和虚拟机栈类似，只不过一个为Java方法服务，一个为本地方法服务。不同的JVM实现对本地方法栈的实现不一样，如HotSpot选择合并了虚拟机栈和本地方法栈。</p><h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>   对于大多数应用来说，堆是虚拟机中内存管理中的最大的一块。<br>   堆是所有线程共享的，所有的对象实例和数组都放到这里(但随着JIT的发展和逃逸分析技术的逐渐成熟，所有对象都在堆上也不那么绝对了)。堆是GC管理的主要区域，由于堆是所有线程共享的，在内存分配时需要同步会造成一些性能开销，所以为了性能Java堆中也可能会划分出线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB，默认开启，可通过开关配置)。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>   方法区和Java堆一样是线程共享的，用于存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。虽然JVM规范将其描述为堆的一个逻辑分区，但是它却有一个别名叫Non-heap。Hotspot把垃圾回收扩展至方法区并使用永久代实现，但是把方法区称为永久代是不恰当的。方法区可以选择不实现垃圾回收，相对而言，GC在这里比较少出现，在这里垃圾回收的目标主要是常量回收和类的卸载，这部分的回收是有必要的。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>   运行时常量池是是方法区的一部分。Class文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。<br>   运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语音并不要求常量一定只能在编译期产生，也可在运行期动态加入，如使用String.intern()方法。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>   直接内存不属于JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域，但是这部分内存被频繁地使用，而且也可能导致OutOfMemoryError出现。<br>   NIO(new Input/Output)类引入了一种基于通道与缓冲区的IO方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用，这样在一些场景中能显著提高性能，因为避免了在Java堆和native堆中来回复制数据。<br>   显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，还是会受到本机总内存的限制。通常管理员在给JVM分配内存时会忽略直接内存的大小，使得各个内存区域的总和大于本机实际内存，当JVM动态扩展内存时就会发生OutOfMemoryError。</p><h1 id="从内存角度看待Java对象的创建"><a href="#从内存角度看待Java对象的创建" class="headerlink" title="从内存角度看待Java对象的创建"></a>从内存角度看待Java对象的创建</h1><img src="/2018/07/27/JVM内存模型/Java对象的创建过程.jpg" title="Java对象的创建过程"><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>   JVM遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那么首先执行相应的类的加载过程。</p><h2 id="对象分配内存"><a href="#对象分配内存" class="headerlink" title="对象分配内存"></a>对象分配内存</h2><p>   对象所需内存的大小在类加载完后便完全确定(对象内存布局)。根据Java堆中是否规整，有两种内存分配方式：</p><ul><li>指针碰撞<br>内存是规整的，使用过的在一边，未使用的在一边，中间放一个指针作为分界指示器，内存分配时把指针移动一段与分配内存大小相等的距离。</li><li>空闲列表<br>内存是不规整的，维持一张表记录那些内存是空闲的以便于内存分配。</li></ul><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>   对象创建时非常频繁的行为，在并发情况下并不安全。所以有同步重试和本地线程分配缓冲(TLAB)来保证这一过程安全。</p><h2 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h2><p>   JVM把分配到的内存空间全部初始化为0(不包括对象头)，如果使用了TLAB这个过程会提前到TLAB分配时执行。</p><h2 id="对象设置"><a href="#对象设置" class="headerlink" title="对象设置"></a>对象设置</h2><p>   虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息放在对象头中。</p><h2 id="执行init"><a href="#执行init" class="headerlink" title="执行init()"></a>执行init()</h2><p>   在上面的工作都完成后，从虚拟机的角度看，一个新的对象已经产生了。但是从Java程序的角度看，对象还没有init，所有字段都为0。一般来说(由字节码中是否跟随invokespecial指令决定)，执行new指令后会接着执行init()方法，把对象照程序员的意愿进行初始化。</p><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>   在HotSpot中，对象在内存中可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>   HotSpot中的对象头包括两部分信息：运行时数据和类型指针。</p><ul><li>运行时数据<br>用于存储对象自身的运行时数据如hashCode、GC分代年龄、锁状态、线程持有的锁，偏向线程ID和偏向时间等。</li><li>类型指针<br>即指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。如果对象是一个数组，那么对象头中还必须有一块记录数组长度的数据。</li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>   实例数据是存储对象真正有效的信息的，记录字段内容(包括从父类中继承的)，相等宽度的字段总是分配到一起，这样可以更紧凑，提高内存使用。</p><h3 id="对齐补充"><a href="#对齐补充" class="headerlink" title="对齐补充"></a>对齐补充</h3><p>   HotSpot要求对象的起始地址必须是8字节的整数倍，也就是对象大小也必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或2倍)，因此，当对象实例部分没有对齐时必须通过对齐来补全。</p><h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>   Java程序需要通过栈上的引用数据来操作堆上的具体对象。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。<br>   句柄，可以理解为指向指针的指针，维护指向对象的指针变化，而对象的句柄本身不发生变化；指针，指向对象，代表对象的内存地址。</p><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br><img src="/2018/07/27/JVM内存模型/句柄方式.jpg"><br>优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。<br><img src="/2018/07/27/JVM内存模型/指针方式.jpg"><br>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。</p>]]></content>
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第一篇 博客开篇词</title>
      <link href="/2018/07/19/%E7%AC%AC%E4%B8%80%E7%AF%87%20%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%E8%AF%8D/"/>
      <url>/2018/07/19/%E7%AC%AC%E4%B8%80%E7%AF%87%20%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>以后将会每周更新一篇文章。</p><p>——2018年7月19号 晚</p>]]></content>
      
      
        <tags>
            
            <tag> 开天辟地 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
